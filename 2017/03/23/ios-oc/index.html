<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!--Description-->
  

  <!--Author-->
  
  <meta name="author" content="talk 田">
  

  <!--Open Graph Title-->
  
      <meta property="og:title" content="oc 语法"/>
  
  <!--Open Graph Description-->
  
  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="talk 田"/>
  <!--Type page-->
  
      <meta property="og:type" content="article" />
  
  <!--Page Cover-->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Title -->
  
  <title>oc 语法 - talk 田</title>


  <link rel="shortcut icon" href="https://hexo.io/icon/favicon-96x96.png">

  <!-- Custom CSS/Sass -->
  <link rel="stylesheet" href="/css/style.css">

  <!----------------------------
  https://github.com/GallenHu/hexo-theme-Daily

 _____            _   _
|  __ \          (_) | |
| |  | |   __ _   _  | |  _   _
| |  | |  / _` | | | | | | | | |
| |__| | | (_| | | | | | | |_| |
|_____/   \__,_| |_| |_|  \__, |
                          __/ |
                         |___/

    --------------------------->

</head>


<body>

  <!-- Nav -->
  <header class="site-header">
  <div class="header-inside">
    <div class="logo">
      <a href="/" rel="home">
        
        <img src="https://hexo.io/logo.svg" alt="talk 田" height="60">
        
      </a>
    </div>
    <!-- Navigation -->
    <nav class="navbar">
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse">
        <ul class="navbar-nav">
          
          
            <li>
              <a href="/.">
                
                  home
                
              </a>
            </li>
          
            <li>
              <a href="/archives">
                
                  archive
                
              </a>
            </li>
          
        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </nav>
    <div class="button-wrap">
      <button class="menu-toggle">Primary Menu</button>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="content-area">
  <div class="post">
    <!-- Post Content -->
    <div class="container">
      <article>
        <!-- Title date & tags -->
        <div class="post-header">
          <h1 class="entry-title">
            oc 语法
            
          </h1>
          <p class="posted-on">
          2017-03-23
          </p>
          <div class="tags-links">
            
              
                <a href="/tags/乱弹琴/" rel="tag">
                  乱弹琴
                </a>
              
            
          </div>
        </div>
        <!-- Post Main Content -->
        <div class="entry-content">
          <h3 id="出识OC"><a href="#出识OC" class="headerlink" title="出识OC"></a>出识OC</h3><p>OC不是一门全新的语言<br>是在C语言的基础上增加了一层最小的面向对象语言<br>OC完全兼容C语言语言 可以在OC代码中混入C语言代码,甚至是C++代码 可以使用OC开发Mac OS X平台和iOS平台的应用程序 </p>
<p>OC程序的源文件后缀名为.m<br>m代表message代表OC的消息机制<br>因为OC语言完全兼容C语言，所以在.m文件中可以写C语言的任何代码，甚至C++的代码也可以写在.m文件下。</p>
<p>在OC程序中，main函数仍然是程序的入口和出口 main函数的写法与C语言main函数的写法完全一样。 主函数都是可以带参数和不带参数.</p>
<p>oc 学习路线<br><img src="http://omoo8c568.bkt.clouddn.com/20170323149026441175519.png" alt="20170323149026441175519.png"></p>
<p>#import 指令是C语言中#include指令的增强版 。 </p>
<p>作用: 将指定文件的内容，在预编译的时候，拷贝到写指令的地方。增强: 同一个文件，无论被#import多少次，在预编译的时候只会包含1次。include指令防止重复包含 需要配合预编译执行来实现。<br>import指令的底层会自动判断这个文件是否被包含,只有没有被包含的时候才会包含。</p>
<p>#import指令包含的时候可以分为双引号和尖括号.<br>“” 包含用户自定义; 会先在当前源文件目录下查找如果没有的话再去Xcode去找<br>&lt;&gt; 包含系统的文件;直接去Xcode编译器中找</p>
<p>我们自己的文件一般都是放在当前源文件目录中，我们自己的文件包含的使用””如果要包含系统的文件&lt;&gt;</p>
<p>关于框架<br>苹果公司或者第三方事先准备的一些功能模块，把这些功能模块封装在1个1个的类之中。这些类的集合就叫做框架.<br>类似于C语言中的函数库。它就是一个功能集合，只不过这些功能集合是苹果公司写的，当我们要使用这个功能的时候，就只需要调用就可以了。</p>
<p>Foundation框架:<br>提供了OC最基础的功能，Foundation的意思就是基础的意思。<br>Foundation头文件的路径。<br>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/ MacOSX10.10.sdk/System/Library/Frameworks/Foundation.framework/Headers<br>Foundation.h这个文件中引入了该框架中的所有的头文件，只要引入这个头文件 就可以使用 Foundation框架中所有的功能了。</p>
<p>NSLog 是printf函数的增强版<br>作用: 向控制台输出数据<br>用法与printf函数用法基本相同<br>增强的地方:<br>A.输出信息之后自动换行<br>B.在输出指定数据的同时，还会输出一些关于调试的信息。<br>会显示出信息的时间: 精确到毫秒 先显示这个信息是由哪个程序输出的。<br>NSLog中放的字符串写法与printf中字符串不同</p>
<p>OC中的字符串<br>在C语言中，字符串常量的写法是用””括起来，代表字符串，而在OC中，是用@”字符串内容”代表字符串。<br>在OC中字符串终于跟int char等数据类型一样开始有了地位，也有了属于自己的数据类型:“NSString”，所以通过声明NSString的指针变量，即可指向OC中的字符串<br>NSString*不能指向C语言中的字符串,否则会报错.<br>NSLog比sprintf多加一个%@占位符,用于输出一个对象</p>
<p>NS前缀<br>NS来自于NeXTStep的一个软件NeXT Software。NS是为了避免命名冲突而给的前缀。<br>在Objective-C应用中的所有类名都必须是全局唯一的。由于很多不同的框架中会有一些相似的功能,所以在名字上也可能会有重复(users,views,requests/responses等等),所以苹果官方文档规定类名需要有2-3个字母作为前缀。 </p>
<p>OC中的三种注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1)单行注释:</div><div class="line">//我是注释的内容</div><div class="line"></div><div class="line">2)多行注释: </div><div class="line">/*注释内容*/</div><div class="line">3)文档注释:</div><div class="line">/**</div><div class="line">* 传说中的文档注释</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>文档注释的作用<br>让自己定义的方法(函数)在Xcode输入时弹出示，用来说明此方法(函数)的作用</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的声明在.h文件中,使用@interface @end关键词,  声明成员变量方法(行为);<br>ps:成员变量的声明在在@interface类名之后的大括号里;</p>
<p>类的实现在.m文件中,用于实现.h中声明的方法和属性, 使用关键字 @implementation @end;</p>
<p>类的定义规范:</p>
<ol>
<li>类名的每个单词首字母大写;</li>
<li>成员的名字以下划线开头;</li>
</ol>
<p>创建类的对象的语法:<br>类名 *对象名 = [类名 new];<br>类成员变量访问方式<br>-&gt; 方式访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person *p = [Person new];</div><div class="line">p-&gt;_age;</div></pre></td></tr></table></figure></p>
<p>. 方式访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person *p = [Person new];</div><div class="line">(*p)._age;</div></pre></td></tr></table></figure></p>
<p>访问级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@public 全局都可以访问</div><div class="line">@protected 只能在类内部和子类中访问(默认)</div><div class="line">@private 只能在类内部访问</div></pre></td></tr></table></figure></p>
<p>类方法调用 以[] 包裹<br>有参方法的方法名包括冒号</p>
<p>#pragma mark<br>对代码的分组，方便代码查找和导航用的 </p>
<p>结构体与类的区别 </p>
<ol>
<li>结构体变量存在栈里面，类实例化出来的对象存在堆里面</li>
<li>结构体里面不能写函数，类里面可以写函数并且可以写方法</li>
<li>结构体成员没有访问权限的说法，类的成员有@public @private @protected三种 </li>
<li>结构体不可以被继承，类可以 </li>
<li>结构体的思想属于面向过程的思维，类是面向对象的产物</li>
</ol>
<p>函数和对象方法的区别</p>
<ol>
<li>语法区别，并且对象方法都以-号开头，函数直接以返回值开头</li>
<li>对象方法的声明只能写@interface…@end中间(不包括写成员变量处)、对象方法的实现只能写在@implementation…@end中</li>
<li>函数属于整个文件,可以写在文件中的任何位置,包括@implementation…@end中,但写在@interface…@end会无法识别，函数的声明可以在main函数内部也可以在main函数外部</li>
<li>对象方法只能由对象来调用，不能像函数一样直接调用</li>
<li>对象方法可以访问当前类的成员，函数哪怕写在@implementation里也不可以直接访问</li>
</ol>
<p>类方法<br>实例方法就是一个方法,它在类的一个具体实例的范围内执行。也就是说，在你调用一 个实例方法前,你必须首先创建类的一个实例。<br>类方法:不需要你创建一个实例。直接用类名就可以调用，不依赖于对象。 </p>
<ul>
<li>表示类方法,就是类调用方法。 </li>
</ul>
<ul>
<li>表示是实例(对象)方法,只能是对象可调用,依赖与任何对象的方法。</li>
</ul>
<p>类方法使用注意事项<br>1)类方法可以和实例方法同名,这个并不影响使用;<br>2)类方法和实例方法一样在@interface里声明,在@implementation里实现。<br>3)类方法只能被类调用执行,向实例对象发送类方法是不能被触发执行的。<br>4)类方法里面不能直接使用实例成员<br>5)类方法里面可以调用其他类方法，打不可以直接调用对象方法<br>6)对象方法里面可以调用类方法</p>
<p>匿名对象<br>简单来说就是没有用指针变量指向的对象叫匿名对象<br>优点:可以简化代码,方便方法调用<br>缺点:匿名对象实例化以后,只能正确的使用成员变量一次 </p>
<p>OC中方法不能重载<br>方法重载是指在一个类中定义多个同名的方法,但要求每个方法具有不同的参数的 类型或参数的个数。调用重载方法时,其他语言(Java、c++)编译器能通过检查调用的方 法的参数类型和 个数选择一个恰当的方法。方法重载通常用于创建完成一组任务相似 但参数的类型或参数的个数 不同的方法 </p>
<p>static关键字<br>OC中与C语言的static关键字功能一样。 但是OC中static不能修饰成员变量，也不能修饰方法! </p>
<p>基类和派生类之间的关系 </p>
<ol>
<li>基类的私有属性能被继承,不能被使用。 </li>
<li>OC中的继承是单继承</li>
<li>继承的合理性 </li>
</ol>
<p>方法的重写<br>从父类继承的方法,可能这个方法并不适合子类,然后子类在不改方法名的前 下，只是修改方法里面具体的实现，就称之为方法的重写。</p>
<p>继承的注意事项 </p>
<ol>
<li>子类不能定义和父类同名的变量,但是可以继承父类的变量 </li>
<li>OC类都是单继承，不支持多重继承 </li>
<li>OC类支持被继承多个类(多派生) </li>
<li>OC类的继承有传递性:即原始基类里定义的属性和方法，在子类的子类中也会被继承过 去 </li>
</ol>
<p>继承体系中方法调用的顺序 </p>
<ol>
<li>在自己类中找</li>
<li>如果没有,去父类中找 </li>
<li>如果父类中没有,就去父类的父类中 </li>
<li>如果父类的父类也没有,就还往上找,直到找到基类(NSObject) </li>
<li>如果NSObject也没有就报错了</li>
</ol>
<p>OC中的私有变量<br>在类的实现即.m @implementation中也可以声明成员变量,但是因为在其他文件中通常都==只是包含头文件而不会包含实现文件==,所以在.m文件中声明的成员变量是@private的。在.m中 定义的成员变量不能和它的头文件.h中的成员变量同名,在这期间使用@public等关键字也是 徒劳的。 </p>
<p>OC中私有方法实现有两种方式: </p>
<ol>
<li>方法在.m中实现,不在.h中声明(相对私有) </li>
<li>通过匿名类别(延展)实现私有(一般意义上的私有) </li>
</ol>
<p>description 方法:</p>
<ol>
<li>类似于java toString(), 在NSLog(@”%@”, obj) 中返回对象的描述信息;</li>
<li>千万不要在对象description方法中同时使用%@和self ,否则会死循环;</li>
</ol>
<p>类的本质<br>类的本质其实也是一个对象(类类型(class)的对象)<br>类对象: </p>
<ul>
<li>类对象在程序运行时一直存在。 </li>
<li>类对象是一种数据结构,存储类的基本信息:类大小,类名称,类的版本以及消息与函数 的映射表等 </li>
<li>类对象所保存的信息在程序编译时确定,在第一次运行程序的时候被加载到内存中。 </li>
<li>类对象代表类,class代表类对象,类方法属于类对象 </li>
<li>如果消息的接收者是类名,则类名代表类对象 </li>
<li>运行时,所有类的实例都由类对象生成,类对象会把实例的isa的值修改成自己的地址, 每 个实例的isa都指向该实例的类对象, </li>
<li>从类对象里可以知道父类信息、可以响应的方法等 *类对象只能使用类方法,不能用实例方法<br>类对象的获取 </li>
<li>通过实例对象获取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Dog *dog = [Dog new]; </div><div class="line">Dog *d2 = [Dog new]; </div><div class="line">//第一种方法获取类对象 </div><div class="line">Class c = [dog class]; </div><div class="line">Class c2 = [d2 class];</div></pre></td></tr></table></figure>
<ul>
<li>通过类名获取 ,类名就是类对象 </li>
</ul>
<p>类对象作用:</p>
<ul>
<li>用来调用类方法 </li>
<li>实例化实例对象 </li>
</ul>
<p>SEL类型:<br>全称selector, 用于表示方法的数据类型;<br>SEL类型作用: </p>
<ol>
<li>可以定义变量 </li>
<li>可以用来作为方法的形参 </li>
<li>可以用来作为方法的实参</li>
</ol>
<p>Objetive-C中的Method结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct objc_method&#123;</div><div class="line">	SEL method_name;//方法名</div><div class="line">	char *method_types; //方法参数类型 IMP </div><div class="line">	method_imp; //方法地址(IMP) </div><div class="line">&#125;;</div><div class="line">typedefobjc_method Method;</div></pre></td></tr></table></figure></p>
<p>什么是IMP<br>– IMP是”implementation”的缩写,它是objetive-C方法(method)实现代码块的地址,类似函数指针,通过它可以直接访问任意一个方法。免去发送消息的代价。<br>获取方法的IMP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(IMP)methodForSelector:(SEL)aSelector;</div><div class="line"></div><div class="line">SEL print_sel =NSSelectorFromString(@“print:”);//获得SEL</div><div class="line">IMP imp=[person methodForSelector:print_sel];//得到IMP </div><div class="line">imp(person,print_sel,@“*********”);//通过IMP直接调用方法等效调用:[person print_sel:@“*********”];</div><div class="line">– imp的第一参数是对象自己(self),第二参数是方法标示,第三个是方法的参数</div></pre></td></tr></table></figure></p>
<p>@class 简单的引入一个类<br>并不会包含类的所有内容<br>@class 相当于引入一个占位符, 告诉编译器这是一个类, 按照一般类来使用就可以了,不用关心这个类里面的内容;<br>这样有两个优点:</p>
<ol>
<li>快,编译过程快;</li>
<li>避免嵌套包含,因为已经告诉编译器了,不要管内部情况是怎样的,只管按照一个类名编译过去就可以了;</li>
</ol>
<p>@autoreleasepool和@autorelease<br>@autoreleasepool是一个自动释放池, 用于自动释放(仅一次)池中的对象;<br>@autorelease ,将对象放入 自动释放池;</p>
<p>分类(Category)的作用:</p>
<ol>
<li>将1个类中的不同方法分到多个不同的文件中存储，便于对类进行模块化设计和团队开发。</li>
<li>可以在不修改原来类的基础上，为这个类扩充一些方法。</li>
<li>注意：<ul>
<li>分类中只能增加“方法”，不能增加成员变量。</li>
<li>分类中可以访问原来类中的成员变量。</li>
</ul>
</li>
</ol>
<p>分类的使用流程</p>
<ul>
<li>声明分类–&gt;实现分类–&gt;使用分类</li>
<li>分类的命名规则:类名+扩展方法, 如“NSString+countNum”。 </li>
<li>分类的接口声明与类的定义十分相似,但分类不继承父类,只需要带有一个括号,表明该分类的主要用途。</li>
</ul>
<p>声明和实现一个分类<br>在.h文件中,声明分类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface 类名 (分类名)</div><div class="line">//方法;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在.m文件中(也可以在.h中实现),实现分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@implementation ClassName(CategoryName) NewMethod</div><div class="line">&#123;</div><div class="line">// 方法实现</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>匿名分类/ 类扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface MyClass ()</div><div class="line">&#123;</div><div class="line">   //类扩展 float value;</div><div class="line">&#125;</div><div class="line">- (void)setValue:(float)newValue;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>分类的一个特例<br>其名字为匿名(为空),并且新添加的方法一定要予以实现。(Category没有这个限制)<br>为本类扩充一些私有的成员变量和私有方法。</p>
<p>分类和类扩展的区别：</p>
<ol>
<li>类别中只能增加方法;</li>
<li>类扩展不仅可以增加方法,还可以增加实例变量(或者合成属性),只是该实例变量默认是私有类型的(作用范围只能在自身类,而不是子类或其他地方);</li>
<li>类扩展中声明的方法没被实现,编译器会报警,但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中,而类别是在运行时添加到类中。</li>
<li>类扩展不能像类别那样拥有独立的实现部分(@implementation部分),也就是说,类扩展所声明的方法必须依托对应类的实现部分来实现。</li>
<li>定义在 .m 文件中的类扩展方法为私有的,定义在 .h 文件(头文件)中的类扩展方法为公有 的。类扩展是在 .m 文件中声明私有方法的非常好的方式。</li>
</ol>
<p>block的作用<br>用来保存一段代码，可以在恰当的时间再取出来调用.<br>语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block名称)(参数列表) = ^(参数列表)&#123;</div><div class="line">// 代码实现；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义一个block 并使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef int(^MyBlock)(int,int);</div><div class="line"></div><div class="line">MyBlock minusBlock = ^(int num1,int num2)&#123;</div><div class="line">return num1 - num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Protocol</p>
<ol>
<li>类似于java 中的接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol 协议名称</div><div class="line">// 各种方法；</div><div class="line">@end</div><div class="line"></div><div class="line">@interface 类名 : NSObject &lt;协议名1，协议名2，...&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>@required和@optional<br>@required：用@required修饰的方法，必须实现。<br>@optional：用@optional修饰的方法，可实现，可不实现。<br>@required 和 @optional的主要意义:一般用于序员交流用。</p>
<p>protocol类型限制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">要求：变量d指向的对象必须遵守PlayProtocol协议</div><div class="line">id&lt;PlayProtocol&gt; d = [[Person alloc] init];</div><div class="line"></div><div class="line">要求：要求Person创建出来的对象，必须遵守PlayProtocol协议。</div><div class="line">Person &lt; PlayProtocol &gt; *p = [[Person alloc] init];</div></pre></td></tr></table></figure></p>
<p>id和instancetype的区别</p>
<ol>
<li>instancetype只能作为函数或者方法的返回值</li>
<li>id能作为方法或者参数的数据类型、返回值，也能用来定义变量。</li>
<li>instancetype能精确的限制返回值的具体类型。</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>涉及了oc 大部分语法相关的概念. 未介绍到的包括内存管理 和 KVC/ KVO;</p>
<p>我认为内存管理是任何一门语言不可避免也是最精华的内容,其他的都是概念,在学习编译器给我们定下的约定, 准守这些约定是记忆的问题, 查就可以了. 而内存管理是编译器不能帮我们解决的 具体的逻辑问题. 不管什么语言, 什么内存管理策略, 逻辑是守恒的,不会因为选择的语言不通而不通.</p>
<p>对于内存管理和 KVC/KVO 等后续补上</p>

        </div>
      </article>
    </div>
    <!-- Comments -->
    <div class="container">
      
<section id="comment">
  <!-- <h1 class="title">Comments</h1> -->

  
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ios-oc" data-title="oc 语法" data-url="https://talkfiled.github.io./2017/03/23/ios-oc/"></div>
    <!-- 多说评论框 end -->
  
</section>


    </div>
    <!-- Pre or Next -->
    <div class="nav-links">
      
        <div class="nav-previous">
          <a href="/2017/03/27/ios-refresh-crash/" rel="prev"><span class="meta-arraw meta-arraw-left"></span> Older Posts</a>
        </div>
      
      
        <div class="nav-next">
          <a href="/2017/03/22/ios-trick/" rel="prev">Newer Posts <span class="meta-arraw meta-arraw-right"></span></a>
        </div>
      
    </div>

  </div>
</div>


  <!-- Footer -->
  <!-- Footer-widgets -->
<div class="footer-widgets">
  <div class="row inside-wrapper">
    <div class="col-1-3">
      <aside>
        <h1 class="widget-title">关于本站</h1>
        <div class="custom-widget-content">
          
          talk田 的博客分享
        </div>
      </aside>
    </div>
    <div class="col-1-3">
      <aside>
        <h1 class="widget-title">Contact</h1>
        <div class="widget-text">
          
            
              <a href="https://github.com/talkfiled" class="icon icon-github" target="_blank">github</a>
            
              <a href="mailto:fogbj2012@gmail.com" class="icon icon-mail" target="_blank">mail</a>
            
          
        </div>
      </aside>
    </div>
    <div class="col-1-3">
      <aside>
        <h1 class="widget-title">Search</h1>
        <div class="widget-text">
          <form onSubmit="return appDaily.submitSearch('')">
            <p>
              <input type="text" placeholder="search..." id="homeSearchInput">
            </p>
            <!-- <input type="submit" value="GO"> -->
          </form>
        </div>
      </aside>
    </div>
  </div>
</div>
<!-- Footer -->
<footer class="site-info">
  <p>
    <span>talk 田 &copy; 2017</span>
    
      <span class="split">|</span>
      <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> with Theme <a href="https://github.com/GallenHu/hexo-theme-Daily" target="_blank">Daily</a></span>
    
  </p>
</footer>


  <!-- After footer scripts -->
  <!-- scripts -->
<script src="/js/app.js"></script>

  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'talk'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->



</body>

</html>